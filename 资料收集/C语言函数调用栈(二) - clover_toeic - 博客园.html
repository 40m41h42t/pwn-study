<!DOCTYPE html>
<!-- saved from url=(0050)http://www.cnblogs.com/clover-toeic/p/3756668.html -->
<html lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="referrer" content="origin">
<title>C语言函数调用栈(二) - clover_toeic - 博客园</title>
<meta property="og:description" content="5 函数调用约定 创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，">
<link type="text/css" rel="stylesheet" href="./C语言函数调用栈(二) - clover_toeic - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./C语言函数调用栈(二) - clover_toeic - 博客园_files/bundle-coffee.css">
<link type="text/css" rel="stylesheet" href="./C语言函数调用栈(二) - clover_toeic - 博客园_files/185661.css">
<link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="./C语言函数调用栈(二) - clover_toeic - 博客园_files/bundle-coffee-mobile.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/clover-toeic/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/clover-toeic/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/clover-toeic/wlwmanifest.xml">
<script async="" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/analytics.js.下载"></script><script type="text/javascript" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/encoder.js.下载"></script><script src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/jquery-2.2.0.min.js.下载"></script>
<script type="text/javascript">var currentBlogApp = 'clover-toeic', cb_enable_mathjax=true;var isLogined=false;</script>
<script type="text/x-mathjax-config;executed=true">
    MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'blogpost-body', processEscapes: true },
        TeX: { 
            equationNumbers: { autoNumber: ['AMS'], useLabelIds: true }, extensions: ['extpfeil.js'] },
            'HTML-CSS': { linebreaks: { automatic: true } },
            SVG: { linebreaks: { automatic: true } }
        });
    </script><script src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/MathJax.js.下载"></script>
<script src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/blog-common.js.下载" type="text/javascript"></script>
<style type="text/css">div[id^="google_ad_"],[id^="ad_"],#banner_right,[id^="cnblogs_a"],[id^="cnblogs_b"],[id^="cnblogs_c"].c_ad_block,[id^="div-gpt-ad-"],[height="60"],.adPopup{display:none!important;display:none}</style><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body><div id="MathJax_Message" style="display: none;"></div>
<a name="top"></a>

<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a id="lnkBlogLogo" href="https://www.cnblogs.com/clover-toeic/"><img id="blogLogo" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/logo.gif" alt="返回主页"></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="https://www.cnblogs.com/clover-toeic/">clover_toeic</a></h1>
<h2></h2>



		
	</div><!--end: blogTitle 博客的标题和副标题 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="navigator">
			
<ul id="navList">
	<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">博客园</a></li>
	<li><a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/clover-toeic/">首页</a></li>
	<li><a id="blog_nav_newpost" class="menu" rel="nofollow" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">新随笔</a></li>
	<li><a id="blog_nav_contact" accesskey="9" class="menu" rel="nofollow" href="https://msg.cnblogs.com/send/clover_toeic">联系</a></li>
	<li><a id="blog_nav_admin" class="menu" rel="nofollow" href="https://i.cnblogs.com/">管理</a></li>
	<li><a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/clover-toeic/rss">订阅</a>
	<a id="blog_nav_rss_image" class="aHeaderXML" href="https://www.cnblogs.com/clover-toeic/rss"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/xml.gif" alt="订阅"></a></li>
</ul>


			<div class="blogStats">
				
				<div id="blog_stats">
<!--done-->
随笔- 80&nbsp;
文章- 0&nbsp;
评论- 122&nbsp;
</div>
				
			</div><!--end: blogStats -->
		</div><!--end: navigator 博客导航栏 -->
		
<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class="postTitle">
			<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/clover-toeic/p/3756668.html">C语言函数调用栈(二)</a>
		</h1>
		<div class="clear"></div>
		<div class="postBody">
			<div id="cnblogs_post_body" class="blogpost-body"><p>&nbsp;</p>
<h1><span style="font-size: 16px;">5 函数调用约定</span></h1>
<p>&nbsp; &nbsp; &nbsp;创建一个栈帧的最重要步骤是主调函数如何向栈中传递函数参数。主调函数必须精确存储这些参数，以便被调函数能够访问到它们。函数通过选择特定的调用约定，来表明其希望以特定方式接收参数。此外，当被调函数完成任务后，调用约定规定先前入栈的参数由主调函数还是被调函数负责清除，以保证程序的栈顶指针完整性。</p>
<p>&nbsp; &nbsp; &nbsp;函数调用约定通常规定如下几方面内容：</p>
<p>&nbsp; &nbsp; &nbsp;1) 函数参数的传递顺序和方式</p>
<p>&nbsp; &nbsp; &nbsp;最常见的参数传递方式是通过堆栈传递。主调函数将参数压入栈中，被调函数以相对于帧基指针的正偏移量来访问栈中的参数。对于有多个参数的函数，调用约定需规定主调函数将参数压栈的顺序(从左至右还是从右至左)。某些调用约定允许使用寄存器传参以提高性能。</p>
<p>&nbsp; &nbsp; &nbsp;2) 栈的维护方式</p>
<p>&nbsp; &nbsp; &nbsp;主调函数将参数压栈后调用被调函数体，返回时需将被压栈的参数全部弹出，以便将栈恢复到调用前的状态。该清栈过程可由主调函数负责完成，也可由被调函数负责完成。</p>
<p>&nbsp; &nbsp; &nbsp;3) 名字修饰(Name-mangling)策略</p>
<p>&nbsp; &nbsp; &nbsp;又称函数名修饰(Decorated Name)规则。编译器在链接时为区分不同函数，对函数名作不同修饰。</p>
<p>&nbsp; &nbsp; &nbsp;若函数之间的调用约定不匹配，可能会产生堆栈异常或链接错误等问题。因此，为了保证程序能正确执行，所有的函数调用均应遵守一致的调用约定。</p>
<p>&nbsp;</p>
<h2><span style="font-size: 15px;">5.1 常见调用约定</span></h2>
<p>&nbsp; &nbsp; &nbsp;下面分别介绍常见的几种函数调用约定。</p>
<p><strong>&nbsp; &nbsp; &nbsp;1. cdecl</strong><strong>调用约定</strong></p>
<p>&nbsp; &nbsp; &nbsp;又称C调用约定，是C/C++编译器默认的函数调用约定。所有非C++成员函数和未使用stdcall或fastcall声明的函数都默认是cdecl方式。函数参数按照从右到左的顺序入栈，函数调用者负责清除栈中的参数，返回值在EAX中。由于每次函数调用都要产生清除(还原)堆栈的代码，故使用cdecl方式编译的程序比使用stdcall方式编译的程序大(后者仅需在被调函数内产生一份清栈代码)。但cdecl调用方式支持可变参数函数(即函数带有可变数目的参数，如printf)，且调用时即使实参和形参数目不符也不会导致堆栈错误。对于C函数，cdecl方式的名字修饰约定是在函数名前添加一个下划线；对于C++函数，除非特别使用extern "C"，C++函数使用不同的名字修饰方式。</p>
<table style="width: 100%; margin-left: auto; margin-right: auto;" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #bdb76b;">
<td>
<div>
<p>【扩展阅读】<strong>可变参数函数支持条件</strong></p>
<p>若要支持可变参数的函数，则参数应自右向左进栈，并且由主调函数负责清除栈中的参数(参数出栈)。</p>
<p>首先，参数按照从右向左的顺序压栈，则参数列表最左边(第一个)的参数最接近栈顶位置。所有参数距离帧基指针的偏移量都是常数，而不必关心已入栈的参数数目。只要不定的参数的数目能根据第一个已明确的参数确定，就可使用不定参数。例如printf函数，第一个参数即格式化字符串可作为后继参数指示符。通过它们就可得到后续参数的类型和个数，进而知道所有参数的尺寸。当传递的参数过多时，以帧基指针为基准，获取适当数目的参数，其他忽略即可。若函数参数自左向右进栈，则第一个参数距离栈帧指针的偏移量与已入栈的参数数目有关，需要计算所有参数占用的空间后才能精确定位。当实际传入的参数数目与函数期望接受的参数数目不同时，偏移量计算会出错！</p>
<p>其次，调用函数将参数压栈，只有它才知道栈中的参数数目和尺寸，因此调用函数可安全地清栈。而被调函数永远也不能事先知道将要传入函数的参数信息，难以对栈顶指针进行调整。</p>
<p>C++为兼容C，仍然支持函数带有可变的参数。但在C++中更好的选择常常是函数多态。</p>
</div>
</td>
</tr>
</tbody>
</table>
<p><strong>&nbsp; &nbsp; &nbsp;2. stdcall</strong><strong>调用约定</strong><strong>(</strong><strong>微软命名</strong><strong>)</strong></p>
<p>&nbsp; &nbsp; &nbsp;Pascal程序缺省调用方式，WinAPI也多采用该调用约定。stdcall调用约定主调函数参数从右向左入栈，除指针或引用类型参数外所有参数采用传值方式传递，由被调函数负责清除栈中的参数，返回值在EAX中。stdcall调用约定仅适用于参数个数固定的函数，因为被调函数清栈时无法精确获知栈上有多少函数参数；而且如果调用时实参和形参数目不符会导致堆栈错误。对于C函数，stdcall名称修饰方式是在函数名字前添加下划线，在函数名字后添加@和函数参数的大小，如_functionname@number。</p>
<p><strong>&nbsp; &nbsp; &nbsp;3. fastcall</strong><strong>调用约定</strong></p>
<p>&nbsp; &nbsp; &nbsp;stdcall调用约定的变形，通常使用ECX和EDX寄存器传递前两个DWORD(四字节双字)类型或更少字节的函数参数，其余参数按照从右向左的顺序入栈，被调函数在返回前负责清除栈中的参数，返回值在 EAX 中。因为并不是所有的参数都有压栈操作，所以比stdcall和cdecl快些。编译器使用两个@修饰函数名字，后跟十进制数表示的函数参数列表大小(字节数)，如@function_name@number。需注意fastcall函数调用约定在不同编译器上可能有不同的实现，比如16位编译器和32位编译器。另外，在使用内嵌汇编代码时，还应注意不能和编译器使用的寄存器有冲突。</p>
<p><strong>&nbsp; &nbsp; &nbsp;4. thiscall</strong><strong>调用约定</strong></p>
<p>&nbsp; &nbsp; &nbsp;C++类中的非静态函数必须接收一个指向主调对象的类指针(this指针)，并可能较频繁的使用该指针。主调函数的对象地址必须由调用者提供，并在调用对象非静态成员函数时将对象指针以参数形式传递给被调函数。编译器默认使用thiscall调用约定以高效传递和存储C++类的非静态成员函数的this指针参数。</p>
<p>&nbsp; &nbsp; &nbsp;thiscall调用约定函数参数按照从右向左的顺序入栈。若参数数目固定，则类实例的this指针通过ECX寄存器传递给被调函数，被调函数自身清理堆栈；若参数数目不定，则this指针在所有参数入栈后再入栈，主调函数清理堆栈。thiscall不是C++关键字，故不能使用thiscall声明函数，它只能由编译器使用。</p>
<p>&nbsp; &nbsp; &nbsp;注意，该调用约定特点随编译器不同而不同，g++中thiscall与cdecl基本相同，只是隐式地将this指针当作非静态成员函数的第1个参数，主调函数在调用返回后负责清理栈上参数；而在VC中，this指针存放在%ecx寄存器中，参数从右至左压栈，非静态成员函数负责清理栈上参数。</p>
<p><strong>&nbsp; &nbsp; &nbsp;5. naked call</strong><strong>调用约定</strong></p>
<p>&nbsp; &nbsp; &nbsp;对于使用naked call方式声明的函数，编译器不产生保存(prologue)和恢复(epilogue)寄存器的代码，且不能用return返回返回值(只能用内嵌汇编返回结果)，故称naked call。该调用约定用于一些特殊场合，如声明处于非C/C++上下文中的函数，并由程序员自行编写初始化和清栈的内嵌汇编指令。注意，naked&nbsp;call并非类型修饰符，故该调用约定必须与__declspec同时使用，如VC下定义求和函数：</p>
<p>&nbsp; &nbsp; &nbsp;代码示例如下(Windows采用Intel汇编语法，注释符为;)：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show(&#39;adbd2407-2cf5-45dc-a67d-593dfcc5e367&#39;)"><img id="code_img_closed_adbd2407-2cf5-45dc-a67d-593dfcc5e367" class="code_img_closed" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ContractedBlock.gif" alt="" style="display: none;"><img id="code_img_opened_adbd2407-2cf5-45dc-a67d-593dfcc5e367" class="code_img_opened" style="" onclick="cnblogs_code_hide(&#39;adbd2407-2cf5-45dc-a67d-593dfcc5e367&#39;,event)" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_adbd2407-2cf5-45dc-a67d-593dfcc5e367" class="cnblogs_code_hide" style="display: block;">
<pre><span style="color: #008080;">1</span> __declspec(naked) <span style="color: #0000ff;">int</span> __stdcall function(<span style="color: #0000ff;">int</span> a, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
</span><span style="color: #008080;">2</span>     <span style="color: #008000;">;</span><span style="color: #008000;">mov DestRegister, SrcImmediate(Intel) vs. movl $SrcImmediate, %DestRegister(AT&amp;T)</span>
<span style="color: #008080;">3</span>     __asm <span style="color: #0000ff;">mov</span><span style="color: #000000;"> eax, a
</span><span style="color: #008080;">4</span>     __asm <span style="color: #0000ff;">add</span><span style="color: #000000;"> eax, b
</span><span style="color: #008080;">5</span>     __asm <span style="color: #0000ff;">ret</span> <span style="color: #800080;">8</span>
<span style="color: #008080;">6</span> }</pre>
</div>
<span class="cnblogs_code_collapse" style="display: none;">View Code</span></div>
<p>&nbsp; &nbsp; &nbsp;注意，__declspec是微软关键字，其他系统上可能没有。&nbsp;</p>
<p><strong>&nbsp; &nbsp; &nbsp;6. pascal</strong><strong>调用约定</strong></p>
<p>&nbsp; &nbsp; &nbsp;Pascal语言调用约定，参数按照从左至右的顺序入栈。Pascal语言只支持固定参数的函数，参数的类型和数量完全可知，故由被调函数自身清理堆栈。pascal调用约定输出的函数名称无任何修饰且全部大写。</p>
<p>&nbsp; &nbsp; &nbsp;Win3.X(16位)时支持真正的pascal调用约定；而Win9.X(32位)以后pascal约定由stdcall约定代替(以C约定压栈以Pascal约定清栈)。</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;上述调用约定的主要特点如下表所示：</p>
<table style="width: 749px; margin-left: auto; margin-right: auto; height: 390px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #827e7d;">
<td valign="top" width="130">
<p style="text-align: center;"><strong>调用方式</strong></p>
</td>
<td style="text-align: center;" valign="top" width="130">
<p><strong>stdcall(Win32)</strong></p>
</td>
<td style="text-align: center;" valign="top" width="83">
<p><strong>cdecl</strong></p>
</td>
<td style="text-align: center;" valign="top" width="142">
<p><strong>fastcall</strong></p>
</td>
<td style="text-align: center;" valign="top" width="118">
<p><strong>thiscall(C++)</strong></p>
</td>
<td valign="top" width="83">
<p style="text-align: center;"><strong>naked call</strong></p>
</td>
</tr>
<tr>
<td width="130">
<p><strong>参数压栈顺序</strong></p>
</td>
<td valign="top" width="130">
<p>从右至左</p>
</td>
<td valign="top" width="83">
<p>从右至左</p>
</td>
<td valign="top" width="142">
<p>从右至左，Arg1在ecx，Arg2在edx</p>
</td>
<td valign="top" width="118">
<p>从右至左，this指针在ecx</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p><strong>参数位置</strong></p>
</td>
<td valign="top" width="130">
<p>栈</p>
</td>
<td valign="top" width="83">
<p>栈</p>
</td>
<td valign="top" width="142">
<p>栈 + 寄存器</p>
</td>
<td valign="top" width="118">
<p>栈，寄存器ecx</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p><strong>负责清栈的函数</strong></p>
</td>
<td valign="top" width="130">
<p>被调函数</p>
</td>
<td valign="top" width="83">
<p><span style="color: #ff0000;">主调函数</span></p>
</td>
<td valign="top" width="142">
<p>被调函数</p>
</td>
<td valign="top" width="118">
<p>被调函数</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p><strong>支持可变参数</strong></p>
</td>
<td valign="top" width="130">
<p>否</p>
</td>
<td valign="top" width="83">
<p><span style="color: #ff0000;">是</span></p>
</td>
<td valign="top" width="142">
<p>否</p>
</td>
<td valign="top" width="118">
<p>否</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p><strong>函数名字格式</strong></p>
</td>
<td valign="top" width="130">
<p>_name@number</p>
</td>
<td valign="top" width="83">
<p>_name</p>
</td>
<td valign="top" width="142">
<p>@name@number</p>
</td>
<td valign="top" width="118">
<p>&nbsp;</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p><strong>参数表开始标识</strong></p>
</td>
<td valign="top" width="130">
<p>"@@YG"</p>
</td>
<td valign="top" width="83">
<p>"@@YA"</p>
</td>
<td valign="top" width="142">
<p>"@@YI"</p>
</td>
<td valign="top" width="118">
<p>&nbsp;</p>
</td>
<td valign="top" width="83">
<p>自定义</p>
</td>
</tr>
<tr>
<td colspan="6" valign="top" width="685">
<p>注：C++因支撑函数重载、命名空间和成员函数等语法特征，采用更为复杂的名字修饰策略。</p>
<p>C++函数修饰名以"?"开始，后面紧跟函数名、参数表开始标识和按照类型代号拼出的返回值参数表。</p>
<p>例如，函数int Function(char *var1,unsigned long)对应的stdcall修饰名为"?Function@@YGHPADK@Z"。</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp; &nbsp; Windows下可直接在函数声明前添加关键字__stdcall、__cdecl或__fastcall等标识确定函数的调用方式，如int __stdcall func()。Linux下可借用函数attribute 机制，如int __attribute__((__stdcall__)) func()。</p>
<p>&nbsp; &nbsp; &nbsp;代码示例如下：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show(&#39;da4b7385-f916-4e34-9761-fb27c953f2f7&#39;)"><img id="code_img_closed_da4b7385-f916-4e34-9761-fb27c953f2f7" class="code_img_closed" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ContractedBlock.gif" alt="" style="display: none;"><img id="code_img_opened_da4b7385-f916-4e34-9761-fb27c953f2f7" class="code_img_opened" style="" onclick="cnblogs_code_hide(&#39;da4b7385-f916-4e34-9761-fb27c953f2f7&#39;,event)" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_da4b7385-f916-4e34-9761-fb27c953f2f7" class="cnblogs_code_hide" style="display: block;"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">int</span> __attribute__((__cdecl__)) CalleeFunc(<span style="color: #0000ff;">int</span> i, <span style="color: #0000ff;">int</span> j, <span style="color: #0000ff;">int</span><span style="color: #000000;"> k){
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">//</span><span style="color: #008000;"> int __attribute__((__stdcall__)) CalleeFunc(int i, int j, int k){
</span><span style="color: #008080;"> 3</span> <span style="color: #008000;">//</span><span style="color: #008000;">int __attribute__((__fastcall__)) CalleeFunc(int i, int j, int k){</span>
<span style="color: #008080;"> 4</span>     <span style="color: #0000ff;">return</span> i+j+<span style="color: #000000;">k;
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 6</span> <span style="color: #0000ff;">void</span> CallerFunc(<span style="color: #0000ff;">void</span><span style="color: #000000;">){
</span><span style="color: #008080;"> 7</span>     CalleeFunc(<span style="color: #800080;">0x11</span>, <span style="color: #800080;">0x22</span>, <span style="color: #800080;">0x33</span><span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span> <span style="color: #000000;">}
</span><span style="color: #008080;"> 9</span> <span style="color: #0000ff;">int</span> main(<span style="color: #0000ff;">void</span><span style="color: #000000;">){
</span><span style="color: #008080;">10</span> <span style="color: #000000;">    CallerFunc();
</span><span style="color: #008080;">11</span>     <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span> }</pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<span class="cnblogs_code_collapse" style="display: none;">View Code</span></div>
<p>&nbsp; &nbsp; &nbsp;被调函数CalleeFunc分别声明为cdecl、stdcall和fastcall约定时，其汇编代码比较如下表所示：</p>
<table style="margin-left: auto; margin-right: auto; height: 511px; width: 806px;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #827e7d;">
<td valign="top" width="80">
<p><strong>&nbsp;</strong></p>
</td>
<td valign="top" width="201">
<p><strong>cdecl</strong></p>
</td>
<td valign="top" width="201">
<p><strong>stdcall</strong></p>
</td>
<td valign="top" width="229">
<p><strong>fastcall</strong></p>
</td>
</tr>
<tr>
<td valign="top" width="80">
<p><strong>主调函数职责</strong></p>
</td>
<td valign="top" width="201">
<p>sub&nbsp;&nbsp; $0xc,%esp</p>
<p>movl&nbsp; $0x33,0x8(%esp)</p>
<p>movl&nbsp; $0x22,0x4(%esp)</p>
<p>movl&nbsp; $0x11,(%esp)</p>
<p>call&nbsp;&nbsp; 8048354 &lt;CalleeFunc&gt;</p>
</td>
<td valign="top" width="201">
<p>sub&nbsp;&nbsp; $0xc,%esp</p>
<p>movl&nbsp; $0x33,0x8(%esp)</p>
<p>movl&nbsp; $0x22,0x4(%esp)</p>
<p>movl&nbsp; $0x11,(%esp)</p>
<p>call &nbsp;&nbsp;8048354 &lt;CalleeFunc&gt;</p>
<p><span style="color: #800080;">sub&nbsp;&nbsp; $0xc,%esp</span></p>
</td>
<td valign="top" width="229">
<p>sub&nbsp;&nbsp; <span style="color: #800080;">$0x4</span>,%esp</p>
<p>movl&nbsp; $0x33,(%esp)</p>
<p>mov&nbsp; $0x22,<span style="color: #800080;">%edx</span></p>
<p>mov&nbsp; $0x11,<span style="color: #800080;">%ecx</span></p>
<p>call&nbsp;&nbsp; 8048354 &lt;CalleeFunc&gt;</p>
<p>sub&nbsp;&nbsp; <span style="color: #800080;">$0x4</span>,%esp</p>
</td>
</tr>
<tr>
<td valign="top" width="80">
<p><strong>被调函数职责</strong></p>
</td>
<td valign="top" width="201">
<p>&nbsp;push %ebp</p>
<p>mov&nbsp; %esp,%ebp</p>
<p>mov&nbsp; 0xc(%ebp),%eax</p>
<p>add&nbsp; 0x8(%ebp),%eax</p>
<p>add&nbsp; 0x10(%ebp),%eax</p>
<p>pop&nbsp; %ebp</p>
<p>ret</p>
</td>
<td valign="top" width="201">
<p>push&nbsp; %ebp</p>
<p>mov&nbsp; %esp,%ebp</p>
<p>mov&nbsp; 0xc(%ebp),%eax</p>
<p>add&nbsp;&nbsp; 0x8(%ebp),%eax</p>
<p>add&nbsp;&nbsp; 0x10(%ebp),%eax</p>
<p>pop&nbsp;&nbsp; %ebp</p>
<p>ret &nbsp;&nbsp;&nbsp;<span style="color: #800080;">$0xc</span>&nbsp;</p>
<p>//执行ret指令并清理参数占用的堆栈(栈顶指针上移参数个数*4=12个字节，以释放压栈的参数)</p>
</td>
<td valign="top" width="229">
<p>push &nbsp;%ebp</p>
<p>mov&nbsp; %esp,%ebp</p>
<p><span style="color: #800080;">sub&nbsp;&nbsp; $0x8,%esp</span></p>
<p>mov&nbsp; %ecx,0xfffffffc(%ebp)</p>
<p>mov&nbsp; %edx,0xfffffff8(%ebp)</p>
<p>mov&nbsp; 0xfffffff8(%ebp),%eax</p>
<p>add&nbsp;&nbsp; 0xfffffffc(%ebp),%eax</p>
<p>add&nbsp;&nbsp; 0x8(%ebp),%eax</p>
<p>leave</p>
<p>ret&nbsp;&nbsp;&nbsp;<span style="color: #800080;"> $0x4</span></p>
<p>//ret &lt;压栈参数字节数&gt;。若参数不超过两个，则ret指令不带立即数，因为无参数被压栈</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2><span style="font-size: 15px;">5.2 调用约定影响</span></h2>
<p>&nbsp; &nbsp; &nbsp;当函数导出被其他程序员所使用(如库函数)时，该函数应遵循主要的调用约定，以便于程序员使用。若函数仅供内部使用，则其调用约定可只被使用该函数的程序所了解。</p>
<p>&nbsp; &nbsp; &nbsp;在多语言混合编程(包括A语言中使用B语言开发的第三方库)时，若函数的原型声明和函数体定义不一致或调用函数时声明了不同的函数约定，将可能导致严重问题(如堆栈被破坏)。</p>
<p>&nbsp; &nbsp; &nbsp;以Delphi调用C函数为例。Delphi函数缺省采用stdcall调用约定，而C函数缺省采用cdecl调用约定。一般将C函数声明为stdcall约定，如：int __stdcall add(int a, int b);</p>
<p>&nbsp; &nbsp; &nbsp;在Delphi中调用该函数时也应声明为stdcall约定：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show(&#39;c2ce7c8b-f8bd-42c4-9180-b38f525908bb&#39;)"><img id="code_img_closed_c2ce7c8b-f8bd-42c4-9180-b38f525908bb" class="code_img_closed" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ContractedBlock.gif" alt="" style="display: none;"><img id="code_img_opened_c2ce7c8b-f8bd-42c4-9180-b38f525908bb" class="code_img_opened" style="" onclick="cnblogs_code_hide(&#39;c2ce7c8b-f8bd-42c4-9180-b38f525908bb&#39;,event)" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_c2ce7c8b-f8bd-42c4-9180-b38f525908bb" class="cnblogs_code_hide" style="display: block;">
<pre><span style="color: #008080;">1</span> <span style="color: #0000ff;">function</span> add(a: Integer; b: Integer): Integer; <span style="color: #0000ff;">stdcall</span>; //<span style="color: #000000;">参数类型应与DLL中的函数或过程参数类型一致，且引用时使用stdcall参数
</span><span style="color: #008080;">2</span> <span style="color: #0000ff;">external</span> <span style="color: #800000;">'</span><span style="color: #800000;">a.dll</span><span style="color: #800000;">'</span>; //指定被调DLL文件的路径和名称</pre>
</div>
<span class="cnblogs_code_collapse" style="display: none;">View Code</span></div>
<p>&nbsp; &nbsp; &nbsp;不同编译器产生栈帧的方式不尽相同，主调函数不一定能正常完成清栈工作；而被调函数必然能自己完成正常清栈，因此，在跨(开发)平台调用中，通常使用stdcall调用约定(不少WinApi均采用该约定)。</p>
<p>&nbsp; &nbsp; &nbsp;此外，主调函数和被调函数所在模块采用相同的调用约定，但分别使用C++和C语法编译时，会出现链接错误(报告被调函数未定义)。这是因为两种语言的函数名字修饰规则不同，解决方式是使用extern "C"告知主调函数所在模块：被调函数是C语言编译的。采用C语言编译的库应考虑到使用该库的程序可能是C++程序(使用C++编译器)，通常应这样声明头文件：</p>
<div class="cnblogs_code" onclick="cnblogs_code_show(&#39;9b7e93a6-15ad-4f6a-83c5-18a5ed59f3ee&#39;)"><img id="code_img_closed_9b7e93a6-15ad-4f6a-83c5-18a5ed59f3ee" class="code_img_closed" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ContractedBlock.gif" alt="" style="display: none;"><img id="code_img_opened_9b7e93a6-15ad-4f6a-83c5-18a5ed59f3ee" class="code_img_opened" style="" onclick="cnblogs_code_hide(&#39;9b7e93a6-15ad-4f6a-83c5-18a5ed59f3ee&#39;,event)" src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/ExpandedBlockStart.gif" alt="">
<div id="cnblogs_code_open_9b7e93a6-15ad-4f6a-83c5-18a5ed59f3ee" class="cnblogs_code_hide" style="display: block;"><div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/copycode.gif" alt="复制代码"></a></span></div>
<pre><span style="color: #008080;">1</span> <span style="color: #000000;">#ifdef _cplusplus
</span><span style="color: #008080;">2</span>     <span style="color: #0000ff;">extern</span> <span style="color: #800000;">"</span><span style="color: #800000;">C</span><span style="color: #800000;">"</span><span style="color: #000000;"> {
</span><span style="color: #008080;">3</span> <span style="color: #0000ff;">#endif</span>
<span style="color: #008080;">4</span> <span style="color: #000000;">    type Func(type para);
</span><span style="color: #008080;">5</span> <span style="color: #000000;">#ifdef _cplusplus
</span><span style="color: #008080;">6</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">7</span> <span style="color: #0000ff;">#endif</span></pre>
<div class="cnblogs_code_toolbar"><span class="cnblogs_code_copy"><a href="javascript:void(0);" onclick="copyCnblogsCode(this)" title="复制代码"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/copycode.gif" alt="复制代码"></a></span></div></div>
<span class="cnblogs_code_collapse" style="display: none;">View Code</span></div>
<p>&nbsp; &nbsp; &nbsp;这样C++编译器就会按照C语言修饰策略链接Func函数名，而不会出现找不到函数的链接错误。</p>
<p>&nbsp;</p>
<h2><span style="font-size: 15px;">5.3 x86函数参数传递方法</span></h2>
<p align="left">&nbsp; &nbsp; &nbsp;x86处理器ABI规范中规定，所有传递给被调函数的参数都通过堆栈来完成，其压栈顺序是以函数参数从右到左的顺序。当向被调函数传递参数时，所有参数最后形成一个数组。由于采用从右到左的压栈顺序，数组中参数的顺序(下标0~N-1)与函数参数声明顺序(Para1~N)一致。因此，在函数中若知道第一个参数地址和各参数占用字节数，就可通过访问数组的方式去访问每个参数。</p>
<h3><span style="font-size: 14px;">5.3.1 整型和指针参数的传递</span></h3>
<p>&nbsp; &nbsp; &nbsp;整型参数与指针参数的传递方式相同，因为在32位x86处理器上整型与指针大小相同(均为四字节)。下表给出这两种类型的参数在栈帧中的位置关系。注意，该表基于tail函数的栈帧。</p>
<table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #827d7d;">
<td valign="top" width="165">
<p align="center"><strong>调用语句</strong></p>
</td>
<td valign="top" width="106">
<p align="center"><strong>参数</strong></p>
</td>
<td valign="top" width="118">
<p align="center"><strong>栈帧地址</strong></p>
</td>
</tr>
<tr>
<td rowspan="4" width="165">
<p>tail(1, 2, 3, (void *)0);</p>
</td>
<td valign="top" width="106">
<p style="text-align: center;">1</p>
</td>
<td style="text-align: center;" valign="top" width="118">
<p>8(%ebp)</p>
</td>
</tr>
<tr>
<td valign="top" width="106">
<p style="text-align: center;">2</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">12(%ebp)</p>
</td>
</tr>
<tr>
<td valign="top" width="106">
<p style="text-align: center;">3</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">16(%ebp)</p>
</td>
</tr>
<tr>
<td style="text-align: center;" valign="top" width="106">
<p>(void *)0</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">20(%ebp)</p>
</td>
</tr>
</tbody>
</table>
<h3><span style="font-size: 14px;">5.3.2 浮点参数的传递</span></h3>
<p>&nbsp; &nbsp; &nbsp;浮点参数的传递与整型类似，区别在于参数大小。x86处理器中浮点类型占8个字节，因此在栈中也需要占用8个字节。下表给出浮点参数在栈帧中的位置关系。图中，调用tail函数的第一个和第三个参数均为浮点类型，因此需各占用8个字节，三个参数共占用20个字节。表中word类型的大小是4字节。</p>
<table style="margin-left: auto; margin-right: auto;" border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #827e7d;">
<td valign="top" width="165">
<p align="center"><strong>调用语句</strong></p>
</td>
<td valign="top" width="130">
<p align="center"><strong>参数</strong></p>
</td>
<td valign="top" width="118">
<p align="center"><strong>栈帧地址</strong></p>
</td>
</tr>
<tr>
<td rowspan="5" width="165">
<p>tail(1.414, 2, 3.998e10);</p>
</td>
<td valign="top" width="130">
<p style="text-align: center;">word 0: 1.414</p>
</td>
<td style="text-align: center;" valign="top" width="118">
<p>8(%ebp)</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p style="text-align: center;">word 1: 1.414</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">12(%ebp)</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p style="text-align: center;">2</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">16(%ebp)</p>
</td>
</tr>
<tr>
<td valign="top" width="130">
<p style="text-align: center;">word 0: 3.998e10</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">20(%ebp)</p>
</td>
</tr>
<tr>
<td style="text-align: center;" valign="top" width="130">
<p>word 1: 3.998e10</p>
</td>
<td valign="top" width="118">
<p style="text-align: center;">24(%ebp)</p>
</td>
</tr>
</tbody>
</table>
<h3><span style="font-size: 14px;">5.3.3 结构体和联合体参数的传递</span></h3>
<p align="left">&nbsp; &nbsp; &nbsp;结构体和联合体参数的传递与整型、浮点参数类似，只是其占用字节大小视数据结构的定义不同而异。x86处理器上栈宽是4字节，故结构体在栈上所占用的字节数为4的倍数。编译器会对结构体进行适当的填充以使得结构体大小满足4字节对齐的要求。</p>
<p align="left">&nbsp; &nbsp; &nbsp;对于一些RISC处理器(如PowerPC)，其参数传递并不是全部通过栈来实现。PowerPC处理器寄存器中，R3～R10共8个寄存器用于传递整型或指针参数，F1～F8共8个寄存器用于传递浮点参数。当所需传递的参数少于8个时，不需要用到栈。结构体和long double参数的传递通过指针来完成，这与x86处理器完全不同。PowerPC的ABI规范中规定，结构体的传递采用指针方式，而不是像x86处理器那样将结构从一个函数栈帧中拷贝到另一个函数栈帧中，显然x86处理器的方式更低效。可见，PowerPC程序中，函数参数采用指向结构体的指针(而非结构体)并不能提高效率，不过通常这是良好的编程习惯。</p>
<p align="left">&nbsp;</p>
<h2><span style="font-size: 15px;">5.4 x86函数返回值传递方法</span></h2>
<p align="left">&nbsp; &nbsp; &nbsp;函数返回值可通过寄存器传递。当被调用函数需要返回结果给调用函数时<strong>：</strong></p>
<p align="left">&nbsp; &nbsp; &nbsp;1) 若返回值不超过4字节(如int、short、char、指针等类型)，通常将其保存在EAX寄存器中，调用方通过读取EAX获取返回值。</p>
<p align="left">&nbsp; &nbsp; &nbsp;2) 若返回值大于4字节而小于8字节(如long long或_int64类型)，则通过EAX+EDX寄存器联合返回，其中EDX保存返回值高4字节，EAX保存返回值低4字节。</p>
<p align="left">&nbsp; &nbsp; &nbsp;3) 若返回值为浮点类型(如float和double)，则通过专用的协处理器浮点数寄存器栈的栈顶返回。</p>
<p>&nbsp; &nbsp; &nbsp;4) 若返回值为结构体或联合体，则主调函数向被调函数传递一个额外参数，该参数指向将要保存返回值的地址。即函数调用foo(p1, p2)被转化为foo(<span style="color: #800080;">&amp;p0</span>, p1, p2)，以引用型参数形式传回返回值。具体步骤可能为：a.主调函数将显式的实参逆序入栈；b.将接收返回值的结构体变量地址作为<span style="color: #800080;">隐藏参数</span>入栈(若未定义该接收变量，则在栈上额外开辟空间作为接收返回值的临时变量)；c. 被调函数将待返回数据拷贝到<span style="color: #800080;">隐藏参数所指向的内存地址</span>，并将该地址存入%eax寄存器。因此，在被调函数中完成返回值的赋值工作。</p>
<p>&nbsp; &nbsp; &nbsp;注意，函数如何传递结构体或联合体返回值依赖于具体实现。不同编译器、平台、调用约定甚至编译参数下可能采用不同的实现方法。如VC6编译器对于不超过8字节的小结构体，会通过EAX+EDX寄存器返回。而对于超过8字节的大结构体，主调函数在栈上分配用于接收返回值的临时结构体，并将地址通过栈传递给被调函数；被调函数根据返回值地址设置返回值(拷贝操作)；调用返回后主调函数根据需要，再将返回值赋值给需要的临时变量(二次拷贝)。实际使用中为提高效率，通常将结构体指针作为实参传递给被调函数以接收返回值。</p>
<p>&nbsp; &nbsp; &nbsp;5) 不要返回指向栈内存的指针，如返回被调函数内局部变量地址(包括局部数组名)。因为函数返回后，其栈帧空间被“释放”，原栈帧内分配的局部变量空间的内容是不稳定和不被保证的。</p>
<p>&nbsp; &nbsp; &nbsp;函数返回值通过寄存器传递，无需空间分配等操作，故返回值的代价很低。基于此原因，C89规范中约定，不写明返回值类型的函数，返回值类型默认为int。但这会带来类型安全隐患，如函数定义时返回值为浮点数，而函数未声明或声明时未指明返回值类型，则调用时默认从寄存器EAX(而不是浮点数寄存器)中获取返回值，导致错误！因此在C++中，不写明返回值类型的函数返回值类型为void，表示不返回值。</p>
<table style="width: 100%; margin-left: auto; margin-right: auto;" cellspacing="0" cellpadding="0">
<tbody>
<tr style="background-color: #bdb76b;">
<td>
<div>
<p>【扩展阅读】<strong>GCC</strong><strong>返回结构体和联合体</strong></p>
<p>通常GCC被配置为使用与目标系统一致的函数调用约定。这通过机器描述宏来实现。但是，在一些目标机上采用不同方式返回结构体和联合体的值。因此，使用PCC编译的返回这些类型的函数不能被使用GCC编译的代码调用，反之亦然。但这并未造成麻烦，因为很少有Unix库函数返回结构体或联合体。</p>
<p>GCC代码使用存放int或double类型返回值的寄存器来返回1、2、4或8个字节的结构体和联合体(GCC通常还将此类变量分配在寄存器中)。其它大小的结构体和联合体在返回时，将其存放在一个由调用者传递的地址中(通常在寄存器中)。</p>
<p>相比之下，PCC在大多目标机上返回任何大小的结构体和联合体时，都将数据复制到一个静态存储区域，再将该地址当作指针值返回。调用者必须将数据从那个内存区域复制到需要的地方。这比GCC使用的方法要慢，而且不可重入。</p>
<p>在一些目标机上(如RISC机器和80386)，标准的系统约定是将返回值的地址传给子程序。在这些机器上，当使用这种约定方法时，GCC被配置为与标准编译器兼容。这可能会对于1，2，4或8字节的结构体不兼容。</p>
<p>GCC使用系统的标准约定来传递参数。在一些机器上，前几个参数通过寄存器传递；在另一些机器上，所有的参数都通过栈传递。原本可在所有机器上都使用寄存器来传递参数，而且此法还可能显著提高性能。但这样就与使用标准约定的代码完全不兼容。所以这种改变只在将GCC作为系统唯一的C编译器时才实用。当拥有一套完整的GNU 系统，能够用GCC来编译库时，可在特定机器上实现寄存器参数传递。</p>
<p>在一些机器上(特别是SPARC)，一些类型的参数通过“隐匿引用”(invisible reference)来传递。这意味着值存储在内存中，将值的内存地址传给子程序。</p>
</div>
</td>
</tr>
</tbody>
</table>
<div>
<div>
<p>&nbsp;</p>
</div>
</div>
<div>&nbsp;</div></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory">分类: <a href="https://www.cnblogs.com/clover-toeic/category/579078.html" target="_blank">语言知识</a></div>
<div id="EntryTag"></div>
<div id="blog_post_info"><div id="green_channel">
        <a href="javascript:void(0);" id="green_channel_digg" onclick="DiggIt(3756668,cb_blogId,1);green_channel_success(this,&#39;谢谢推荐！&#39;);">好文要顶</a>
            <a id="green_channel_follow" onclick="follow(&#39;b6689109-c220-e311-8d02-90b11c0b17d6&#39;);" href="javascript:void(0);">关注我</a>
    <a id="green_channel_favorite" onclick="AddToWz(cb_entryId);return false;" href="javascript:void(0);">收藏该文</a>
    <a id="green_channel_weibo" href="javascript:void(0);" title="分享至新浪微博" onclick="ShareToTsina()"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/icon_weibo_24.png" alt=""></a>
    <a id="green_channel_wechat" href="javascript:void(0);" title="分享至微信" onclick="shareOnWechat()"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/wechat.png" alt=""></a>
</div>
<div id="author_profile">
    <div id="author_profile_info" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/clover-toeic/" target="_blank"><img src="./C语言函数调用栈(二) - clover_toeic - 博客园_files/20140515221533.png" class="author_avatar" alt=""></a>
        <div id="author_profile_detail" class="author_profile_info">
            <a href="http://home.cnblogs.com/u/clover-toeic/">clover_toeic</a><br>
            <a href="http://home.cnblogs.com/u/clover-toeic/followees">关注 - 15</a><br>
            <a href="http://home.cnblogs.com/u/clover-toeic/followers">粉丝 - 181</a>
        </div>
    </div>
    <div class="clear"></div>
    <div id="author_profile_honor"></div>
    <div id="author_profile_follow">
                <a href="javascript:void(0);" onclick="follow(&#39;b6689109-c220-e311-8d02-90b11c0b17d6&#39;);return false;">+加关注</a>
    </div>
</div>
<div id="div_digg">
    <div class="diggit" onclick="votePost(3756668,&#39;Digg&#39;)">
        <span class="diggnum" id="digg_count">7</span>
    </div>
    <div class="buryit" onclick="votePost(3756668,&#39;Bury&#39;)">
        <span class="burynum" id="bury_count">0</span>
    </div>
    <div class="clear"></div>
    <div class="diggword" id="digg_tips">
    </div>
</div>
<script type="text/javascript">
    currentDiggType = 0;
</script></div>
<div class="clear"></div>
<div id="post_next_prev"><a href="https://www.cnblogs.com/clover-toeic/p/3755545.html" class="p_n_p_prefix">« </a> 上一篇：<a href="https://www.cnblogs.com/clover-toeic/p/3755545.html" title="发布于2014-05-28 09:53">MDU某产品OMCI模块代码质量现状分析</a><br><a href="https://www.cnblogs.com/clover-toeic/p/3757194.html" class="p_n_p_prefix">» </a> 下一篇：<a href="https://www.cnblogs.com/clover-toeic/p/3757194.html" title="发布于2014-05-29 08:30">将模块代码量精简为2%的实践</a><br></div>
</div>


		</div>
		<div class="postDesc">posted @ <span id="post-date">2014-05-28 16:02</span> <a href="https://www.cnblogs.com/clover-toeic/">clover_toeic</a> 阅读(<span id="post_view_count">4340</span>) 评论(<span id="post_comment_count">8</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=3756668" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#" onclick="AddToWz(3756668);return false;">收藏</a></div>
	</div>
	<script type="text/javascript">var allowComments=true,cb_blogId=185661,cb_entryId=3756668,cb_blogApp=currentBlogApp,cb_blogUserGuid='b6689109-c220-e311-8d02-90b11c0b17d6',cb_entryCreatedDate='2014/5/28 16:02:00';loadViewCount(cb_entryId);var cb_postType=1;</script>
	
</div><!--end: topics 文章、评论容器-->
</div><a name="!comments"></a><div id="blog-comments-placeholder"><div id="comments_pager_top"></div>
<!--done-->
<br>
<div class="feedback_area_title">评论</div>
<div class="feedbackNoItems"></div>
	

		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#2952705" class="layer">#1楼</a><a name="2952705" id="comment_anchor_2952705"></a> <span class="comment_date">2014-05-29 09:05</span> | <a id="a_comment_author_2952705" href="https://www.cnblogs.com/hlxs/" target="_blank">啊汉</a> <a href="http://msg.cnblogs.com/send/%E5%95%8A%E6%B1%89" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_2952705" class="blog_comment_body">这内容不错啊，请问楼主这些知识是从哪里学到的</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(2952705,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(2952705,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_2952705_avatar" style="display:none;">http://pic.cnblogs.com/face/142192/20130515104024.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#2952746" class="layer">#2楼</a><a name="2952746" id="comment_anchor_2952746"></a>[<span class="louzhu">楼主</span>] <span class="comment_date">2014-05-29 09:34</span> | <a id="a_comment_author_2952746" href="https://www.cnblogs.com/clover-toeic/" target="_blank">clover_toeic</a> <a href="http://msg.cnblogs.com/send/clover_toeic" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_2952746" class="blog_comment_body"><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#2952705" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,2952705);">@</a>
啊汉<br>主要是兴趣驱动的。根据工作中遇到的某个小问题横向纵向延伸，如“已释放的栈内存”-&gt;“缓冲区溢出”-&gt;“函数调用栈”-&gt;“可变参数函数”...，这期间参考各种资料，结合自身理解和编程实践，整理后就是上述产物。<br>选到点后深究的过程中，会强迫您去接触基础或外围的知识。这种被动方式适合我这种记性不好的人，主动学习反而容易遗忘。至于来源，谷哥度娘随处都有，呵呵~</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(2952746,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(2952746,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_2952746_avatar" style="display:none;">http://pic.cnblogs.com/face/569008/20140515221533.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3387242" class="layer">#3楼</a><a name="3387242" id="comment_anchor_3387242"></a> <span class="comment_date">2016-03-21 18:13</span> | <a id="a_comment_author_3387242" href="https://www.cnblogs.com/findumars/" target="_blank">findumars</a> <a href="http://msg.cnblogs.com/send/findumars" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3387242" class="blog_comment_body">不错，整理的表格很整齐。但是我好奇一下，有没有参数压栈从左到右的调用方式呢？以前记得有，现在怎么也找不到了，难道没有？</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3387242,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3387242,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3387242_avatar" style="display:none;">http://pic.cnblogs.com/face/341522/20171127200121.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3389484" class="layer">#4楼</a><a name="3389484" id="comment_anchor_3389484"></a>[<span class="louzhu">楼主</span>] <span class="comment_date">2016-03-23 15:47</span> | <a id="a_comment_author_3389484" href="https://www.cnblogs.com/clover-toeic/" target="_blank">clover_toeic</a> <a href="http://msg.cnblogs.com/send/clover_toeic" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3389484" class="blog_comment_body"><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3387242" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3387242);">@</a>
findumars<br>Pascal语言调用约定，参数按照从左至右的顺序入栈。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3389484,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3389484,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3389484_avatar" style="display:none;">http://pic.cnblogs.com/face/569008/20140515221533.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3390990" class="layer">#5楼</a><a name="3390990" id="comment_anchor_3390990"></a> <span class="comment_date">2016-03-24 19:00</span> | <a id="a_comment_author_3390990" href="https://www.cnblogs.com/findumars/" target="_blank">findumars</a> <a href="http://msg.cnblogs.com/send/findumars" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3390990" class="blog_comment_body"><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3389484" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3389484);">@</a>
clover_toeic<br>Pascal的调用方式，没有在您的列表中列出。而且这个名字非常误导人，其实Delphi都不用它，更不用说C++，现在应该没什么人用了吧。但是我老是把它和FastCall混起来，真是烦死人啊。</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3390990,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3390990,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3390990_avatar" style="display:none;">http://pic.cnblogs.com/face/341522/20171127200121.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3394351" class="layer">#6楼</a><a name="3394351" id="comment_anchor_3394351"></a>[<span class="louzhu">楼主</span>] <span class="comment_date">2016-03-29 12:23</span> | <a id="a_comment_author_3394351" href="https://www.cnblogs.com/clover-toeic/" target="_blank">clover_toeic</a> <a href="http://msg.cnblogs.com/send/clover_toeic" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3394351" class="blog_comment_body"><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3390990" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3390990);">@</a>
findumars<br>pascal调用约定已被stdcall代替，可参考<a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank">维基百科</a>相关描述：<br>Based on the Pascal programming language's calling convention, the parameters are pushed on the stack in left-to-right order (opposite of cdecl), and the callee is responsible for balancing the stack before return.<br>This calling convention was common in the following 16-bit APIs: OS/2 1.x, Microsoft Windows 3.x, and Borland Delphi version 1.x. Modern versions of the Windows API use stdcall, which still has the callee restoring the stack as in the Pascal convention, but the parameters are now pushed right to left.</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3394351,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3394351,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3394351_avatar" style="display:none;">http://pic.cnblogs.com/face/569008/20140515221533.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3395106" class="layer">#7楼</a><a name="3395106" id="comment_anchor_3395106"></a> <span class="comment_date">2016-03-29 22:56</span> | <a id="a_comment_author_3395106" href="https://www.cnblogs.com/findumars/" target="_blank">findumars</a> <a href="http://msg.cnblogs.com/send/findumars" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3395106" class="blog_comment_body">谢谢这么详细的描述。话说您最近不怎么写博客了呢？我是有点事情都往博客上扔，既当总结，又当查询用～</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3395106,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3395106,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3395106_avatar" style="display:none;">http://pic.cnblogs.com/face/341522/20171127200121.png</span>
			</div>
		</div>
	
		<div class="feedbackItem">
			<div class="feedbackListSubtitle">
				<div class="feedbackManage">
					&nbsp;&nbsp;<span class="comment_actions"></span>
				</div>
				<a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3395410" class="layer">#8楼</a><a name="3395410" id="comment_anchor_3395410"></a>[<span class="louzhu">楼主</span>]<span id="comment-maxId" style="display:none;">3395410</span><span id="comment-maxDate" style="display:none;">2016/3/30 10:55:30</span> <span class="comment_date">2016-03-30 10:55</span> | <a id="a_comment_author_3395410" href="https://www.cnblogs.com/clover-toeic/" target="_blank">clover_toeic</a> <a href="http://msg.cnblogs.com/send/clover_toeic" title="发送站内短消息" class="sendMsg2This">&nbsp;</a>
			</div>
			<div class="feedbackCon">
				<div id="comment_body_3395410" class="blog_comment_body"><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#3395106" title="查看所回复的评论" onclick="commentManager.renderComments(0,50,3395106);">@</a>
findumars<br>谢谢关注，哈哈~<br>其间因为有其他事情，博客更新中断了一年。目前是遇到疑难问题时，总结下相关的知识，比如这个月的三篇。后面应该也是这样的节奏，甚至停更也说不定呢......</div><div class="comment_vote"><a href="javascript:void(0);" class="comment_digg" onclick="return voteComment(3395410,&#39;Digg&#39;,this)">支持(0)</a><a href="javascript:void(0);" class="comment_bury" onclick="return voteComment(3395410,&#39;Bury&#39;,this)">反对(0)</a></div><span id="comment_3395410_avatar" style="display:none;">http://pic.cnblogs.com/face/569008/20140515221533.png</span>
			</div>
		</div>
	<div id="comments_pager_bottom"></div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/clover-toeic/p/3756668.html#top">返回顶部</a></div>
<div id="comment_form_container"><div class="login_tips">注册用户登录后才能发表评论，请 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return login(&#39;commentform&#39;);">登录</a> 或 <a rel="nofollow" href="javascript:void(0);" class="underline" onclick="return register();">注册</a>，<a href="http://www.cnblogs.com/">访问</a>网站首页。</div></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="ad_t2"></div>
<div id="opt_under_post"></div>
<div id="cnblogs_c1" class="c_ad_block"></div>
<div id="under_post_news"><div class="itnews c_ad_block"><b>最新IT新闻</b>:<br> ·  <a href="https://news.cnblogs.com/n/607358/" target="_blank">Facebook正招募人权政策主任 肃清仇恨言论</a><br> ·  <a href="https://news.cnblogs.com/n/607373/" target="_blank">Linus Torvalds宣布休息 为过去的行为道歉</a><br> ·  <a href="https://news.cnblogs.com/n/607383/" target="_blank">迅雷与新大陆战略合作 出售部分区块链业务</a><br> ·  <a href="https://news.cnblogs.com/n/607376/" target="_blank">传微软下月将对Windows团队展开架构重组</a><br> ·  <a href="https://news.cnblogs.com/n/607368/" target="_blank">雷军WAIC 2018大会演讲：人类进入人工智能新时代</a><br>» <a href="http://news.cnblogs.com/" title="IT新闻" target="_blank">更多新闻...</a></div></div>
<div id="cnblogs_c2" class="c_ad_block"></div>
<div id="under_post_kb"><div class="itnews c_ad_block" id="kb_block"><b>最新知识库文章</b>:<br><div id="kb_recent"> ·  <a href="https://kb.cnblogs.com/page/606682/" target="_blank">为什么说 Java 程序员必须掌握 Spring Boot ？</a><br> ·  <a href="https://kb.cnblogs.com/page/606645/" target="_blank">在学习中，有一个比掌握知识更重要的能力</a><br> ·  <a href="https://kb.cnblogs.com/page/603663/" target="_blank">如何招到一个靠谱的程序员</a><br> ·  <a href="https://kb.cnblogs.com/page/573614/" target="_blank">一个故事看懂“区块链”</a><br> ·  <a href="https://kb.cnblogs.com/page/603697/" target="_blank">被踢出去的用户</a><br></div>» <a href="https://kb.cnblogs.com/" target="_blank">更多知识库文章...</a></div></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
    fixPostBody();
    setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
    deliverAdT2();
    deliverAdC1();
    deliverAdC2();    
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);   
</script>
</div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<!--done-->
<div class="newsItem">
<h3 class="catListTitle">公告</h3>
	<div id="blog-news"><div id="profile_block">昵称：<a href="https://home.cnblogs.com/u/clover-toeic/">clover_toeic</a><br>园龄：<a href="https://home.cnblogs.com/u/clover-toeic/" title="入园时间：2013-09-19">4年11个月</a><br>粉丝：<a href="https://home.cnblogs.com/u/clover-toeic/followers/">181</a><br>关注：<a href="https://home.cnblogs.com/u/clover-toeic/followees/">15</a><div id="p_b_follow"><a href="javascript:void(0);" onclick="follow(&#39;b6689109-c220-e311-8d02-90b11c0b17d6&#39;)">+加关注</a></div><script>getFollowStatus('b6689109-c220-e311-8d02-90b11c0b17d6')</script></div></div><script type="text/javascript">loadBlogNews();</script>
</div>

			<div id="calendar"><div id="blog-calendar" style=""><table id="blogCalendar" class="Cal" cellspacing="0" cellpadding="0" title="Calendar">
	<tbody><tr><td colspan="7"><table class="CalTitle" cellspacing="0">
		<tbody><tr><td class="CalNextPrev"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/08/01&#39;);return false;">&lt;</a></td><td align="center">2018年9月</td><td class="CalNextPrev" align="right"><a href="javascript:void(0);" onclick="loadBlogCalendar(&#39;2018/10/01&#39;);return false;">&gt;</a></td></tr>
	</tbody></table></td></tr><tr><th class="CalDayHeader" align="center" abbr="日" scope="col">日</th><th class="CalDayHeader" align="center" abbr="一" scope="col">一</th><th class="CalDayHeader" align="center" abbr="二" scope="col">二</th><th class="CalDayHeader" align="center" abbr="三" scope="col">三</th><th class="CalDayHeader" align="center" abbr="四" scope="col">四</th><th class="CalDayHeader" align="center" abbr="五" scope="col">五</th><th class="CalDayHeader" align="center" abbr="六" scope="col">六</th></tr><tr><td class="CalOtherMonthDay" align="center">26</td><td class="CalOtherMonthDay" align="center">27</td><td class="CalOtherMonthDay" align="center">28</td><td class="CalOtherMonthDay" align="center">29</td><td class="CalOtherMonthDay" align="center">30</td><td class="CalOtherMonthDay" align="center">31</td><td class="CalWeekendDay" align="center">1</td></tr><tr><td class="CalWeekendDay" align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td class="CalWeekendDay" align="center">8</td></tr><tr><td class="CalWeekendDay" align="center">9</td><td align="center">10</td><td align="center">11</td><td align="center">12</td><td align="center">13</td><td align="center">14</td><td class="CalWeekendDay" align="center">15</td></tr><tr><td class="CalWeekendDay" align="center">16</td><td class="CalTodayDay" align="center">17</td><td align="center">18</td><td align="center">19</td><td align="center">20</td><td align="center">21</td><td class="CalWeekendDay" align="center">22</td></tr><tr><td class="CalWeekendDay" align="center">23</td><td align="center">24</td><td align="center">25</td><td align="center">26</td><td align="center">27</td><td align="center">28</td><td class="CalWeekendDay" align="center">29</td></tr><tr><td class="CalWeekendDay" align="center">30</td><td class="CalOtherMonthDay" align="center">1</td><td class="CalOtherMonthDay" align="center">2</td><td class="CalOtherMonthDay" align="center">3</td><td class="CalOtherMonthDay" align="center">4</td><td class="CalOtherMonthDay" align="center">5</td><td class="CalOtherMonthDay" align="center">6</td></tr>
</tbody></table></div><script type="text/javascript">loadBlogDefaultCalendar();</script></div>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"><div id="sidebar_search" class="sidebar-block"></div><div id="sidebar_toptags" class="sidebar-block"></div><div id="sidebar_categories">
<div class="catListPostCategory">
<h3 class="catListTitle">随笔分类</h3>

<ul>

<li><a id="CatList_LinkList_0_Link_0" href="https://www.cnblogs.com/clover-toeic/category/579079.html">编程实践(44)</a> </li>

<li><a id="CatList_LinkList_0_Link_1" href="https://www.cnblogs.com/clover-toeic/category/580637.html">工具介绍(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_2" href="https://www.cnblogs.com/clover-toeic/category/580882.html">设计优化(5)</a> </li>

<li><a id="CatList_LinkList_0_Link_3" href="https://www.cnblogs.com/clover-toeic/category/579357.html">思维火花(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_4" href="https://www.cnblogs.com/clover-toeic/category/585344.html">算法实现(2)</a> </li>

<li><a id="CatList_LinkList_0_Link_5" href="https://www.cnblogs.com/clover-toeic/category/580875.html">通信系统(3)</a> </li>

<li><a id="CatList_LinkList_0_Link_6" href="https://www.cnblogs.com/clover-toeic/category/582887.html">硬件电路(4)</a> </li>

<li><a id="CatList_LinkList_0_Link_7" href="https://www.cnblogs.com/clover-toeic/category/579078.html">语言知识(17)</a> </li>

</ul>

</div>

</div><div id="sidebar_recentcomments" class="sidebar-block"><div id="recent_comments_wrap">
<div class="catListComment">
<h3 class="catListTitle">最新评论</h3>

	<div id="RecentCommentsBlock"><ul>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/clover-toeic/p/3736748.html#4031912">1. Re:可变参数函数详解</a></li>
        <li class="recent_comment_body">详细！</li>
        <li class="recent_comment_author">--丢了木剑的温华</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html#3997388">2. Re:C语言字节对齐问题详解</a></li>
        <li class="recent_comment_body">@蒋明昊恩，你是对的。不过实际开发中通常会显式指定pack的。...</li>
        <li class="recent_comment_author">--clover_toeic</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html#3991786">3. Re:C语言字节对齐问题详解</a></li>
        <li class="recent_comment_body">感谢楼主分享。关于“数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定的pack值}。”这句话是需要再深入一下的。个人认为，如果代码中没有显式......</li>
        <li class="recent_comment_author">--蒋明昊</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/clover-toeic/p/3741115.html#3954623">4. Re:基于VLAN的二三层转发</a></li>
        <li class="recent_comment_body">@clover_toeic之前邮箱收到回复提醒了，不好意思现在才回复，前段时间有点忙，谢谢了...</li>
        <li class="recent_comment_author">--unidl</li>
        <li class="recent_comment_title"><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html#3943789">5. Re:C语言字节对齐问题详解</a></li>
        <li class="recent_comment_body">面试被问题什么是字节对齐。<br>不了解，特意查了下。文章说得很详细，很清晰。谢谢谢谢！</li>
        <li class="recent_comment_author">--TonyYPZhang</li>
</ul>
</div>
</div>
</div></div><div id="sidebar_topviewedposts" class="sidebar-block"><div id="topview_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">阅读排行榜</h3>
	<div id="TopViewPostsBlock"><ul><li><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">1. C语言字节对齐问题详解(29977)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html">2. Linux虚拟地址空间布局(15240)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">3. C语言函数调用栈(一)(14114)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3851102.html">4. C语言预处理命令详解(14066)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/5491073.html">5. Python标准输出重定向(14016)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topcommentedposts" class="sidebar-block"><div id="topfeedback_posts_wrap">
<div class="catListFeedback">
<h3 class="catListTitle">评论排行榜</h3>
	<div id="TopFeedbackPostsBlock"><ul><li><a href="https://www.cnblogs.com/clover-toeic/p/3741115.html">1. 基于VLAN的二三层转发(14)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3842758.html">2. 我的代码重构经验(12)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">3. C语言字节对齐问题详解(9)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3730362.html">4. C语言表驱动法编程实践(8)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3765286.html">5. 研究生期间做项目所学到的一些经验(8)</a></li></ul></div>
</div>
</div></div><div id="sidebar_topdiggedposts" class="sidebar-block"><div id="topdigg_posts_wrap">
<div class="catListView">
<h3 class="catListTitle">推荐排行榜</h3>
<div id="TopDiggPostsBlock"><ul><li><a href="https://www.cnblogs.com/clover-toeic/p/3853132.html">1. C语言字节对齐问题详解(29)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3755401.html">2. C语言函数调用栈(一)(23)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html">3. Linux虚拟地址空间布局(22)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3851102.html">4. C语言预处理命令详解(21)</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3741115.html">5. 基于VLAN的二三层转发(17)</a></li></ul></div>
</div></div></div></div><script type="text/javascript">loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		
<!--done-->
Copyright ©2018 clover_toeic
	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


</body></html>